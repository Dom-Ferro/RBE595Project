#
# In the ARGoS window, you can move the camera with the following commands:
#
# - Translation: W A S D Q E keys, right-click + drag
# - Rotation: left-click + drag
#
# Selection: shift-click on the robot
# Remove selection: shift-click elsewhere
#
# Bug: selection is finnicky in the top-down view (Camera 1).
# Solution: switch to another camera and it'll work.
#

# This function is executed once at init time
function init() {
	#if (id == 0){
	#	log("green when driving")
	#	log("orange when an obstacle is near")
	#	log("red when obstacle is very close")
	#	log("flashes black to flash")
	#}
	
	T = 100
	k = 0.4
	
	GREEN = 1
	BLUE = 0
	# give a seed or all the robots pick the same random number
	math.rng.setseed(id)
	c = math.rng.uniform(0,100)

	# no magic numbers
	base_speed = 10.0
	turning_mod = 0.5
	lin_mod = 0.1
	colliding = 0
	vision = 90 #cm
	e = 5000
	desired_dist = 50.0 #cm
	goal_x = 2.5
	goal_y = -2.5
	NUM_ROBOTS = 30

	#grid things
	bb_dist = 50.0
	gg_dist = 50.0 * math.sqrt(2)
	bg_dist = 50.0
	
	# write things to the rsobot 
	#set_wheels(base_speed, base_speed)
	#set_leds(r, g, b)

	blue = swarm.create(1) # swarm 0
	green = swarm.create(2) # swarm 1

	
	blue.select(id % 2 == 0)
	green.select(id % 2 == 1)

	if (blue.in())
		set_leds(0,0,255)
	else
		set_leds(0,255,0)

	turn = 0

	same_neighbors = {} # neighbors.kin()
	non_same = {} # neighbors.nonkin()
 	friends = {}
	listener()

}

# This function is executed at each time step
# The main loop is controller by ARGoS
function step() {
	same_neighbors = get_kin() # neighbors.kin()
	non_same = get_nonkin() # neighbors.nonkin()
	#log(non_same)	
	green.exec(function(){
		neighbors.broadcast(string.tostring(id),  GREEN)})
	blue.exec(function(){
		neighbors.broadcast(string.tostring(id),  BLUE)})

	vec = {}
	vec.x = 0.0
	vec.y = 0.0

	if (turn == id) {
		log(non_same.poses)
		check_switch(same_neighbors, non_same)
	}
	turn = turn + 1
	turn = turn % NUM_ROBOTS

	#calculate the vectors for the attraction/repulsion
	if (size(non_same) > 0){
		non_same.foreach(function(rid,data) {
			#log("AAAAAAaaah")
			#log(neighbors.poses[rid])
			x = math.cos(data.azimuth)*F(data.distance, bg_dist, vision)
			y = math.sin(data.azimuth)*F(data.distance, bg_dist, vision)

			vec.x = vec.x + x
			vec.y = vec.y + y
		})
	}
	
	
	same_dist = bb_dist
	if (green.in())
		same_dist = gg_dist

	same_neighbors.foreach(function(rid,data) {
		x = math.cos(data.azimuth)*F(data.distance, same_dist, vision)
		y = math.sin(data.azimuth)*F(data.distance, same_dist, vision)

		vec.x = vec.x + x
		vec.y = vec.y + y
	})



	

	goal_vec_x = (goal_x - pose.position.x) * 0.01
	#log("vec x: ", vec.x, ", goal vec x: ", goal_vec_x)
	vec.x = vec.x + goal_vec_x
	goal_vec_y = (goal_y - pose.position.y) * 0.01
	vec.y = vec.y + goal_vec_y


	vecsum = math.abs(vec.x) + math.abs(vec.y)

	sx = vec.x
	sy = vec.y
	if (vecsum > base_speed) {
		sx = (vec.x / vecsum) * base_speed
		sy = (vec.y / vecsum) * base_speed
	}

	

	#move along the vector
	gotoc(sx, sy)
		#scale the vector?


}

function get_nonkin(){
	nearby = neighbors.filter(function(rid, data){
		return data.distance < vision})
	
	return nearby.filter(function(rid, data){
		return friends[string.tostring(rid)] != friends[string.tostring(id)] 
	})
}

function get_kin(){
	nearby = neighbors.filter(function(rid, data){
		return data.distance < vision})
	
	return nearby.filter(function(rid, data){
		return friends[string.tostring(rid)] == friends[string.tostring(id)] 
	})
}

function switch_swarm(){
	if(blue.in()){
		blue.leave()
		green.join()
		neighbors.broadcast(string.tostring(id), GREEN)
		friends[string.tostring(id)] = GREEN
		set_leds(0, 255, 0)
	}
	else if(green.in()){
		green.leave()
		blue.join()
		neighbors.broadcast(string.tostring(id), BLUE)
		friends[string.tostring(id)] = BLUE
		set_leds(0, 0, 255)
	}
	else {
		log("uh oh, spaghettios, :-O")
		set_leds(255, 0, 0)
	}
	
}

function listener(){
	x = 0
	while(x<30) {
		#if (data.distance < vision){
			neighbors.listen(string.tostring(x), function(vid, value, rid){
				friends[string.tostring(rid)] = value
			})
		x = x + 1
		#}
	}
	if (blue.in()) {
		friends[string.tostring(id)] = BLUE
	} 
	else if (green.in()) {
		friends[string.tostring(id)] = GREEN
	} 
	else {
		friends[string.tostring(id)] = 3
	}
}

function F(dist, desire, vision) {
	#factor = (4 * e)/dist
	#log("dist: ", dist, " desired: ", desired_dist)
	#first_expo = (desired_dist / dist)^4
	#second_expo = (desired_dist / dist)^2
	#force = factor * (first_expo - second_expo)
	force = 0.0
	if (dist < desired_dist)
		force = -20*((desired_dist/dist)^3)
	else if ((dist > desired_dist) and (dist < vision))
		force = dist/desired_dist
	return force
}


function check_switch(same_neighbors, non_same) {
	num_same = 0.0
	num_diff = 0.0
	same_neighbors.foreach(function(rid,data) {
		num_same = num_same + 1.0
	})
	non_same.foreach(function(rid, data) {
		num_diff = num_diff + 1.0
	})

	percent_same = num_same / (num_same + num_diff)
	debug.print("num same: ", num_same, " num_diff: ", num_diff, "percent_same: ", percent_same)

	if (percent_same > 0.5)
		switch_swarm()
}

# This function is executed when you press the reset button
function reset() {
}

# This function is executed once when you close the simulator
function destroy() {
}
