#
# In the ARGoS window, you can move the camera with the following commands:
#
# - Translation: W A S D Q E keys, right-click + drag
# - Rotation: left-click + drag
#
# Selection: shift-click on the robot
# Remove selection: shift-click elsewhere
#
# Bug: selection is finnicky in the top-down view (Camera 1).
# Solution: switch to another camera and it'll work.
#

#
# Compiling and running the code
#
# - In the ARGoS window: Pause the simulation (if it's not paused already)
# - In the editor: do what you need, save, press the "Execute" button
# - In the ARGoS window: Press the "Play", "Step", or "Fast Forward" buttons
#

#
# This editor sucks.
#
# I know.
#
# But when it's open, it detects whether the open files have been modified elsewhere.
# So open this editor and then open the file you wanna edit in your favorite editor.
# When you save in your editor, the changes will be reflected here. Press Execute to compile and run.
# If you want syntax highlighting, JavaScript is pretty similar to Buzz.
#

# This function is executed once at init time
function init() {
	if (id == 0){
		log("green when driving")
		log("orange when an obstacle is near")
		log("red when obstacle is very close")
		log("flashes black to flash")
	}
	
	T = 100
	k = 0.4
	# give a seed or all the robots pick the same random number
	math.rng.setseed(id)
	c = math.rng.uniform(0,100)
	# want to practice swarms
	flash = swarm.create(1)
	# add everyone to flash if the count is over T
	flash.select(c >= T)
	# add everyone else to nonflash swarm
	nonflash = flash.others(2)
	# RGB!!!!
	r = 0
	g = 255
	b = 0
	# no magic numbers
	base_speed = 10.0
	turning_mod = 0.5
	lin_mod = 0.1
	colliding = 0
	
	# write things to the robot 
	set_wheels(base_speed, base_speed)
	set_leds(r, g, b)
}

# This function is executed at each time step
# The main loop is controller by ARGoS
function step() {
	var colide_angles = {}
	colliding = 0
	bad = 0
	# figure out what swarm you should be in
	flash.leave()
	flash.select(c >= T)
	nonflash = flash.others(2)
	# all robots in the flash swarm say you are a flash
	# I CANNOT get nonkin() to return a list of anything 
	# nonkin().count() is always returning 0??
	flash.exec(function(){
		neighbors.broadcast("flash", 1)
	})
	# make everyone else listen 
	nonflash.exec(function(){
		neighbors.listen("flash", function(vid, value, rid){
			c = c + k*c
		})
	})
	
	# check all the sensors in front of the robot if they see anything
	foreach(proximity, function(key, value){
		if (value.value > 0 and ((key < 2.5) or (key > 5.5))){
			# rgb to 'orange'
			r = 255
			g = 100
			set_leds(255, 100, 0)
			# we will hit something remember where the things are
			colliding = 1
			colide_angles[key] = value.angle
		}
		# if its too close take drastic measures
		if (value.value > 0.7 and ((key < 2.5) or (key > 5.5))){
			# rgb red, we are too close it is bad
			r = 255
			g = 0
			bad = 1
		}	
		})
	
	# if the robot sensed something
	if (colliding){
		sum = 0
		num = 0
		# sum the angles and get number of angles to average
		foreach(colide_angles, function(key, value){
			sum = sum + value
			num = num + 1
		})
		# dividing by 0 quits argos
		if (num > 0){
			# get the average angle where it senses obstacles
			avg_angle = sum/num 
			# want the collisions behind the robot
			face = avg_angle - math.pi 
			# makes a nice gentle arc away from collisions
			ang_speed = face*turning_mod
			lin_speed = base_speed*face*lin_mod
			# whoops too close
			if (bad){
				# turn in place
				lin_speed = 0
				ang_speed = base_speed*(face/(math.abs(face)))
			}
			# set the robot to actually move
			gotop(lin_speed, ang_speed)
		}
	}
	else{
	# not coliding, rgb green :D
		r = 0
		g = 255
		# full speed ahead
		gotop(base_speed, 0.0)
	}

	# if its in the flash swarm
	if (flash.in()){
		# RGB black
		r = 0
		g = 0
		b = 0
		# reset count (will force it to not join flash swarm next round)
		c = 0
	}
	else{
		# not flashing, increment count
		c = c + 1
	}
	
	# actually set RGB to the right color
	set_leds(r, g, b)
}

# This function is executed when you press the reset button
function reset() {
}

# This function is executed once when you close the simulator
function destroy() {
}
